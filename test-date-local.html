<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Date Column Local</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .test-section { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        
        .laps-header {
            display: grid;
            grid-template-columns: 45px 100px 80px 80px 80px 80px 45px 45px;
            background: #6366f1;
            color: white;
            font-weight: 600;
            font-size: 0.75rem;
            padding: 8px;
            gap: 6px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .lap-item {
            display: grid;
            grid-template-columns: 45px 100px 80px 80px 80px 80px 45px 45px;
            padding: 6px 8px;
            border-bottom: 1px solid #ddd;
            gap: 6px;
            align-items: center;
            font-size: 0.8rem;
        }
        
        .sortable { cursor: pointer; }
        .sort-indicator { font-size: 0.7rem; margin-left: 4px; }
        
        .best-time { background: #fbbf24; color: #000; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üß™ Test Colonne Date - Local</h1>
    
    <div class="test-section">
        <h3>üìä Test avec donn√©es simul√©es</h3>
        <button onclick="testWithMockData()">Tester avec donn√©es mock</button>
        <div id="results"></div>
    </div>
    
    <div class="test-section">
        <h3>üìã Liste des tours g√©n√©r√©e</h3>
        <div id="lapsList"></div>
    </div>

    <script>
        // Donn√©es mock pour simuler un pilote
        const mockDriver = {
            lapTimes: [
                {
                    sessionDate: '20240115_143022',
                    laptime: 120500,
                    splits: [30000, 40000, 50500],
                    isValid: true,
                    isWet: false
                },
                {
                    sessionDate: '20240116_091530',
                    laptime: 119800,
                    splits: [29500, 39500, 50800],
                    isValid: true,
                    isWet: false
                },
                {
                    sessionDate: '20240117_162045',
                    laptime: 121200,
                    splits: [31000, 41000, 49200],
                    isValid: false,
                    isWet: true
                },
                {
                    sessionDate: '20240118_110000',
                    laptime: 120100,
                    splits: [29800, 40200, 50100],
                    isValid: true,
                    isWet: false
                },
                {
                    sessionDate: '15/01/2024 14:30:22',
                    laptime: 119500,
                    splits: [29000, 39500, 51000],
                    isValid: true,
                    isWet: false
                }
            ]
        };
        
        function testWithMockData() {
            const results = document.getElementById('results');
            const lapsList = document.getElementById('lapsList');
            
            console.log('üß™ Test avec donn√©es mock...');
            
            // G√©n√©rer la liste des tours
            const lapsHTML = generateLapsList(mockDriver);
            lapsList.innerHTML = lapsHTML;
            
            // Analyser les r√©sultats
            const lapItems = document.querySelectorAll('.lap-item');
            let emptyDates = 0;
            let validDates = 0;
            
            lapItems.forEach((item, index) => {
                const dataDate = item.dataset.date;
                const dateSpan = item.querySelectorAll('span')[1];
                const dateText = dateSpan.textContent;
                
                console.log(`Tour ${index + 1}:`);
                console.log(`  data-date: "${dataDate}"`);
                console.log(`  Date affich√©e: "${dateText}"`);
                
                if (!dataDate || dataDate === '' || dataDate === 'undefined') {
                    emptyDates++;
                    console.log(`  ‚ùå PROBL√àME: Pas de data-date`);
                } else {
                    validDates++;
                    console.log(`  ‚úÖ OK: data-date valide`);
                }
                
                if (!dateText || dateText.trim() === '' || dateText === '--') {
                    console.log(`  ‚ùå PROBL√àME: Date vide affich√©e`);
                } else {
                    console.log(`  ‚úÖ OK: Date affich√©e`);
                }
            });
            
            results.innerHTML = `
                <div class="${emptyDates === 0 ? 'success' : 'error'}">
                    ${emptyDates === 0 ? '‚úÖ' : '‚ùå'} Dates valides: ${validDates}/${lapItems.length}
                </div>
                <div class="${emptyDates > 0 ? 'error' : 'success'}">
                    ${emptyDates === 0 ? '‚úÖ' : '‚ùå'} Dates vides: ${emptyDates}
                </div>
            `;
            
            // Test du tri
            console.log('üîÑ Test du tri par date...');
            testSorting();
        }
        
        function generateLapsList(driver) {
            if (!driver || !driver.lapTimes || driver.lapTimes.length === 0) {
                return '<p class="no-data">Aucun tour disponible</p>';
            }

            // Calculer les meilleurs temps
            const bestTimes = calculateBestLapTimes(driver.lapTimes);

            const lapsHeader = `
                <div class="laps-header">
                    <span class="sortable" onclick="sortLapsTable('lapNumber', this)">
                        Tour <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('date', this)">
                        Date <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('total', this)">
                        Total <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('split1', this)">
                        S1 <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('split2', this)">
                        S2 <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('split3', this)">
                        S3 <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('valid', this)">
                        Valide <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                    <span class="sortable" onclick="sortLapsTable('wet', this)">
                        Wet <span class="sort-indicator">‚ÜïÔ∏è</span>
                    </span>
                </div>
            `;

            const lapsItems = driver.lapTimes.map((lap, index) => generateLapItem(lap, index, bestTimes)).join('');
            
            return lapsHeader + `<div class="laps-list" id="lapsList">${lapsItems}</div>`;
        }
        
        function calculateBestLapTimes(lapTimes) {
            let bestS1 = Infinity;
            let bestS2 = Infinity;
            let bestS3 = Infinity;
            let bestTotal = Infinity;
            
            lapTimes.forEach(lap => {
                const splits = lap.splits || [];
                const lapTime = lap.laptime || lap.time || 0;
                
                if (splits[0] && splits[0] < bestS1) bestS1 = splits[0];
                if (splits[1] && splits[1] < bestS2) bestS2 = splits[1];
                if (splits[2] && splits[2] < bestS3) bestS3 = splits[2];
                if (lapTime > 0 && lapTime < bestTotal) bestTotal = lapTime;
            });
            
            return {
                s1: bestS1 !== Infinity ? bestS1 : 0,
                s2: bestS2 !== Infinity ? bestS2 : 0,
                s3: bestS3 !== Infinity ? bestS3 : 0,
                total: bestTotal !== Infinity ? bestTotal : 0
            };
        }
        
        function generateLapItem(lap, index, bestTimes = null) {
            const lapTime = lap.laptime || lap.time || 0;
            const isValid = lap.isValid === true;
            const isWet = lap.isWet === true || lap.isWetSession === true || lap.sessionWet === true;
            
            const isValidClass = isValid ? 'valid' : 'invalid';
            const isWetClass = isWet ? 'wet' : 'dry';
            
            // D√©terminer si c'est un meilleur temps
            const splits = lap.splits || [];
            const isBestTotal = bestTimes && lapTime > 0 && lapTime === bestTimes.total;
            const isBestS1 = bestTimes && splits[0] && splits[0] === bestTimes.s1;
            const isBestS2 = bestTimes && splits[1] && splits[1] === bestTimes.s2;
            const isBestS3 = bestTimes && splits[2] && splits[2] === bestTimes.s3;
            
            // Formater la date de session
            const sessionDate = lap.sessionDate || '';
            const formattedDate = sessionDate ? formatSessionDate(sessionDate) : '--';
            
            console.log(`G√©n√©ration tour ${index + 1}: sessionDate="${sessionDate}" -> formattedDate="${formattedDate}"`);
            
            return `
                <div class="lap-item ${isValidClass} ${isWetClass}" 
                     data-lap-number="${index + 1}"
                     data-date="${sessionDate}"
                     data-total-time="${lapTime}"
                     data-split1-time="${splits[0] || 0}"
                     data-split2-time="${splits[1] || 0}"
                     data-split3-time="${splits[2] || 0}"
                     data-is-valid="${isValid}"
                     data-is-wet="${isWet}">
                    <span>${index + 1}</span>
                    <span>${formattedDate}</span>
                    <span class="${isBestTotal ? 'best-time' : ''}">${lapTime > 0 ? formatTime(lapTime) : '--:--.---'}</span>
                    <span class="${isBestS1 ? 'best-time' : ''}">${splits[0] ? formatTime(splits[0]) : '--'}</span>
                    <span class="${isBestS2 ? 'best-time' : ''}">${splits[1] ? formatTime(splits[1]) : '--'}</span>
                    <span class="${isBestS3 ? 'best-time' : ''}">${splits[2] ? formatTime(splits[2]) : '--'}</span>
                    <span>${isValid ? '‚úì' : '‚úó'}</span>
                    <span>${isWet ? 'üíß' : '‚òÄÔ∏è'}</span>
                </div>
            `;
        }
        
        function formatSessionDate(sessionDate) {
            if (!sessionDate) return '--';
            
            console.log(`Formatage de la date: "${sessionDate}"`);
            
            // Si c'est d√©j√† un format lisible, le retourner tel quel
            if (sessionDate.includes('/') || sessionDate.includes('-')) {
                console.log(`  -> Format d√©j√† lisible: ${sessionDate}`);
                return sessionDate;
            }
            
            // Essayer de parser diff√©rents formats de date
            try {
                // Format de fichier typique: "20240115_143022"
                if (sessionDate.match(/^\d{8}_\d{6}$/)) {
                    const datePart = sessionDate.substring(0, 8);
                    const timePart = sessionDate.substring(9, 15);
                    const year = datePart.substring(0, 4);
                    const month = datePart.substring(4, 6);
                    const day = datePart.substring(6, 8);
                    const hour = timePart.substring(0, 2);
                    const minute = timePart.substring(2, 4);
                    const second = timePart.substring(4, 6);
                    const formatted = `${day}/${month}/${year} ${hour}:${minute}:${second}`;
                    console.log(`  -> Format fichier pars√©: ${formatted}`);
                    return formatted;
                }
                
                // Format ISO ou autre
                const date = new Date(sessionDate);
                if (!isNaN(date.getTime())) {
                    const formatted = date.toLocaleDateString('fr-FR') + ' ' + date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                    console.log(`  -> Format ISO pars√©: ${formatted}`);
                    return formatted;
                }
                
                // Retourner tel quel si aucun format reconnu
                console.log(`  -> Format non reconnu, retour tel quel: ${sessionDate}`);
                return sessionDate;
            } catch (error) {
                console.warn('Erreur lors du formatage de la date:', sessionDate, error);
                return sessionDate;
            }
        }
        
        function formatTime(milliseconds) {
            if (!milliseconds || milliseconds === 0) return '--:--.---';
            
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const ms = milliseconds % 1000;
            
            return `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }
        
        function testSorting() {
            console.log('üîÑ Test du tri par date...');
            
            // Simuler le tri
            const lapItems = document.querySelectorAll('.lap-item');
            const dates = Array.from(lapItems).map(item => item.dataset.date);
            
            console.log('Dates avant tri:', dates);
            
            // Tri alphab√©tique
            const sortedDates = [...dates].sort((a, b) => a.localeCompare(b));
            console.log('Dates apr√®s tri alphab√©tique:', sortedDates);
            
            // V√©rifier que le tri fonctionne
            const isSorted = JSON.stringify(dates) === JSON.stringify(sortedDates);
            console.log(`Tri correct: ${isSorted ? 'OUI' : 'NON'}`);
        }
        
        // Fonction de tri (simul√©e)
        window.sortLapsTable = function(column, headerElement) {
            console.log(`Tri par colonne: ${column}`);
            
            const lapsList = document.getElementById('lapsList');
            if (!lapsList) return;
            
            const lapItems = Array.from(lapsList.children);
            if (lapItems.length === 0) return;
            
            // D√©terminer l'ordre de tri
            const currentSort = headerElement.getAttribute('data-sort') || 'none';
            const newSort = currentSort === 'asc' ? 'desc' : 'asc';
            
            console.log(`Nouvel ordre de tri: ${newSort}`);
            
            // R√©initialiser tous les indicateurs de tri
            document.querySelectorAll('.laps-header .sort-indicator').forEach(indicator => {
                indicator.textContent = '‚ÜïÔ∏è';
            });
            
            // Mettre √† jour l'indicateur de la colonne courante
            const indicator = headerElement.querySelector('.sort-indicator');
            indicator.textContent = newSort === 'asc' ? '‚Üë' : '‚Üì';
            headerElement.setAttribute('data-sort', newSort);
            
            // Trier les √©l√©ments
            lapItems.sort((a, b) => {
                let aValue, bValue;
                
                switch (column) {
                    case 'lapNumber':
                        aValue = parseInt(a.dataset.lapNumber);
                        bValue = parseInt(b.dataset.lapNumber);
                        break;
                    case 'date':
                        aValue = a.dataset.date || '';
                        bValue = b.dataset.date || '';
                        // Tri alphab√©tique pour les dates
                        if (newSort === 'asc') {
                            return aValue.localeCompare(bValue);
                        } else {
                            return bValue.localeCompare(aValue);
                        }
                    case 'total':
                        aValue = parseFloat(a.dataset.totalTime) || Infinity;
                        bValue = parseFloat(b.dataset.totalTime) || Infinity;
                        break;
                    default:
                        return 0;
                }
                
                if (newSort === 'asc') {
                    return aValue - bValue;
                } else {
                    return bValue - aValue;
                }
            });
            
            // R√©organiser les √©l√©ments dans le DOM
            lapItems.forEach(item => lapsList.appendChild(item));
            
            console.log('Tri termin√©');
        };
        
        // Initialisation
        console.log('üöÄ Test local initialis√©');
    </script>
</body>
</html>
